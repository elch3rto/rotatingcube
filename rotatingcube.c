/* 
  ___ ___ ___  ___ _      _   ___ __  __ ___ ___ 
 |   \_ _/ __|/ __| |    /_\ |_ _|  \/  | __| _ \
 | |) | |\__ \ (__| |__ / _ \ | || |\/| | _||   /
 |___/___|___/\___|____/_/ \_\___|_|  |_|___|_|_\
                                                 
This code is written poorly. It has many flaws, it is 
badly optimised, it does not manage memory correctly, it
may cause unpredicted crashes and reboots, and its
formatting does not follow Flipper Zero developer 
guidelines. Also parts of code have been borrowed from 
applications/examples/example_images/example_images.c
*/

#include <furi.h>
#include <furi_hal.h>
#include <string.h>
#include <stdbool.h>
#include <gui/gui.h>
#include <input/input.h>
#include <math.h>

/* Magic happens here -- this file is generated by fbt.
 * Just set fap_icon_assets in application.fam and #include {APPID}_icons.h */
#include "rotatingcube_icons.h"

static uint8_t x_screen_center = 63;
static uint8_t y_screen_center = 31;
static uint8_t cube_size = 20;
//#define DEBUG

static double DEGTORAD = 3.1415 / 180;

/*
typedef struct {
    uint8_t x1, y1;
    uint8_t x2, y2;
} line;
*/
typedef struct {
    uint8_t leftoffset, topoffset;
} offset;

typedef struct {
    int16_t x, y, z;
} Point;

typedef struct {
    uint8_t x1, y1, x2, y2;
} Line;

//static Point point1 = {20, 20, 0};
//static Point point2 = {20, -20, 0};
//static Point point3 = {-20, -20, 0};
//static Point point4 = {-20, 20, 0};

static int32_t yawangle = 0;
static int32_t pitchangle = 0;
static bool move_or_rotate = false;
// Screen is 128x64 px

//RIGHT NOW THIS FUNCTION IS UNUSED!
Point* calculate_points_for_cube(int16_t size) {
    /* 
    We need: 
        4 dots in upper part
        4 dots in lower part
        Distance x +- size/2 and y +- size/2 and z +- size/2
        3 - +   4 + +       7 - +   8 + +
                       

        1 - -   2 + -       5 - -   6 + -   
        WHAT points[8] WILL LOOK LIKE:
        [0] {-10,-10,-10}    /
        [1] {10, -10,-10}   |  Z is less than 0   
        [2] {-10, 10,-10}   |  LOWER LAYER 
        [3] {10,  10,-10}    \
          -------------
        [4] {-10,-10, 10}  \     
        [5] {10, -10, 10}   | Z is more than 0    
        [6] {-10, 10, 10}   | UPPER LAYER
        [7] {10,  10, 10}  /     
    
    */
    Point points[8];

    int16_t halfsize = size / 2;

    for(uint8_t i = 0; i < 8; i++) {
        //points[i].x = halfsize * (i & 1) + halfsize * ((i & 1) - 1);
        //points[i].y = halfsize * (i & 2) / 2 + halfsize * (((i & 2) / 2) - 1);
        //points[i].z = halfsize * (i << 2) + halfsize * ((i << 2) - 1);

        points[i].x = (i == 0 || i == 2 || i == 4 || i == 6 ? -halfsize : halfsize);
        points[i].y = (i == 0 || i == 1 || i == 4 || i == 5 ? -halfsize : halfsize);
        points[i].z = (i < 4 ? -halfsize : halfsize);
        //  little binary trick to fill in all the combinations
        //  of positive and negative signs
    }
    /*
    for(uint8_t i = 0; i < 12; i++) {
        uint8_t n;
        uint8_t m;

        if(i <= 3) {
            n = i;
            m = (i == 0 ? 3 : i - 1);
        }
        if(i >= 4 && i <= 7) {
            n = i;
            m = (i == 4 ? 7 : i - 1);
        }
        if(i >= 8 && i <= 11) {
            n = i - 8;
            m = i - 4;
        }
        else{
            break;
        }

        lines[i] =
            (Line){.x1 = points[n].x, .y1 = points[n].y, .x2 = points[m].x, .y2 = points[m].y};
    }
*/
    Point* ptr_to_points = &points[0];
    return ptr_to_points;
}

//THIS FUNCTION TAKES A POINT AND APPLIES ROTATION ON 2 AXIS TO IT
Point calculate_point(Point point, int32_t YawAngle, int32_t PitchAngle) {
    double diag_yaw;
    double diag_pitch;
    double prev_yaw_RAD;
    double prev_pitch_RAD;
    double yaw_RAD = YawAngle * DEGTORAD;
    double pitch_RAD = PitchAngle * DEGTORAD;

    // 1: We rotate the point along the PITCH axis
    /*

  SCREEN
    |              y
    |              |-X(z,y)
    |              | |
    64     --------|---------z
    |              |
    |              |
  SCREEN      
      */

    diag_pitch = sqrt(pow(point.y, 2) + pow(point.z, 2));
    prev_pitch_RAD = atan2(point.y, point.z);
    pitch_RAD += prev_pitch_RAD;
    point.y = (diag_pitch * cos(pitch_RAD));
    point.z = (diag_pitch * sin(pitch_RAD));

    // 2: We rotate the point along the YAW axis
    /*            z
                  |----X(x,z)
                  |    |
          --------|--------x
                  |
                  |
        
    SCREEN_______128________SCREEN
    */

    diag_yaw = sqrt(pow(point.x, 2) + pow(point.z, 2));
    prev_yaw_RAD = atan2(point.z, point.x);
    yaw_RAD += prev_yaw_RAD;
    point.x = (diag_yaw * cos(yaw_RAD));
    point.z = (diag_yaw * sin(yaw_RAD));

    return point;
}

//######### THE DRAW FUNCTION #########
//THIS FUNCTION TAKES ALL DATA, RUNS THE POINT POSITION CALCULATION AND DISPLAYS THE LINES
//THAT REPRESENT THE CUBE

static void app_draw_callback(Canvas* canvas, void* ctx) {
    UNUSED(ctx);

    canvas_clear(canvas);
    //canvas_draw_icon(canvas, image_position.x % 128, image_position.y % 64, &I_test25);

    // Available fonts
    // FontPrimary, FontSecondary, FontKeyboard, FontBigNumbers
    // visit --- applications/gui/canvas.c
    canvas_set_font(canvas, FontKeyboard);

    //TODO: TRANSFER CUBE GENERATION TO ANOTHER FUNCTION

    uint8_t num_of_points = 8;

    Point points[8];

    //Point* points_ptr = calculate_points_for_cube(20);

    // I pasted this in from another function in order to test
    int16_t halfsize = cube_size;

    for(uint8_t i = 0; i < 8; i++) {
        points[i].x = (i == 0 || i == 3 || i == 4 || i == 7 ? -halfsize : halfsize);
        points[i].y = (i == 0 || i == 1 || i == 4 || i == 5 ? -halfsize : halfsize);
        points[i].z = (i < 4 ? -halfsize : halfsize);
        // fill in all the combinations
        //  of positive and negative signs
    }
    //TODO: ENDS HERE

    for(uint8_t i = 0; i < num_of_points; i += 1) {
        points[i] = calculate_point(points[i], yawangle, pitchangle);
    }

    for(uint8_t i = 0; i < 12; i++) {
        uint8_t n;
        uint8_t m;

        if(i <= 3) {
            n = i;
            m = (i == 0 ? 3 : i - 1);
        } else if(i >= 4 && i <= 7) {
            n = i;
            m = (i == 4 ? 7 : i - 1);
        } else if(i >= 8 && i <= 11) {
            n = i - 8;
            m = i - 4;
        } else {
            break;
        }

        canvas_draw_line(
            canvas,
            (points[n].x + x_screen_center) % 128,
            (points[n].y + y_screen_center) % 64,
            (points[m].x + x_screen_center) % 128,
            (points[m].y + y_screen_center) % 64);
    }

#ifdef DEBUG
    for(uint8_t i = 0; i < 56; i += 7) {
        char debug_str[32];
        snprintf(debug_str, 32, "%d %d %d", points[i / 7].x, points[i / 7].y, points[i / 7].z);
        canvas_draw_str_aligned(canvas, 5, i, AlignLeft, AlignTop, debug_str);
    }

#endif

//STRINGS FOR ROTATION DATA ON THE SCREEN
#ifndef DEBUG
    char strone[32];
    char strtwo[32];

    snprintf(strone, 32, "Z: %ld deg.", yawangle);
    snprintf(strtwo, 32, "X: %ld deg.", pitchangle);
    canvas_draw_str_aligned(canvas, 5, 0, AlignLeft, AlignTop, strone);
    canvas_draw_str_aligned(canvas, 5, 10, AlignLeft, AlignTop, strtwo);
#endif
    //STRINGS FOR ROTATION DATA ON THE SCREEN
}

//######### CALLBACK(THIS RUNS WHEN A BUTTON IS PRESSED) #########

static void app_input_callback(InputEvent* input_event, void* ctx) {
    furi_assert(ctx); // ====> WRITES TO DEBUG FILE,

    FuriMessageQueue* event_queue = ctx;
    furi_message_queue_put(event_queue, input_event, FuriWaitForever);
}

//######### MAIN FUNCTION(THIS RUNS AT START) #########

int32_t rotation_main(void* p) {
    UNUSED(p);
    FuriMessageQueue* event_queue = furi_message_queue_alloc(8, sizeof(InputEvent));

    // Configure view port
    ViewPort* view_port = view_port_alloc();
    view_port_draw_callback_set(view_port, app_draw_callback, view_port);
    view_port_input_callback_set(view_port, app_input_callback, event_queue);

    // Register view port in GUI
    Gui* gui = furi_record_open(RECORD_GUI);
    gui_add_view_port(gui, view_port, GuiLayerFullscreen);

    InputEvent event;

    bool running = true;
    while(running) {
        if(furi_message_queue_get(event_queue, &event, 100) == FuriStatusOk) {
            if((event.type == InputTypePress) || (event.type == InputTypeRepeat)) {
                switch(event.key) {
                case InputKeyRight:
                    if(move_or_rotate) {
                        if(yawangle >= -355) {
                            yawangle -= 5;
                        }
                    } else {
                        if(x_screen_center < 122 - cube_size * 1.4) {
                            x_screen_center += 5;
                        }
                    }

                    break;
                case InputKeyLeft:
                    if(move_or_rotate) {
                        if(yawangle <= 355) {
                            yawangle += 5;
                        }
                    } else {
                        if(x_screen_center > 4 + cube_size) {
                            x_screen_center -= 5;
                        }
                    }

                    break;
                case InputKeyDown:
                    if(move_or_rotate) {
                        if(pitchangle <= 355) {
                            pitchangle += 5;
                        }
                    } else {
                        if(y_screen_center < 58 - cube_size) {
                            y_screen_center += 5;
                        }
                    }
                    break;
                case InputKeyUp:
                    if(move_or_rotate) {
                        if(pitchangle >= -355) {
                            pitchangle -= 5;
                        }
                    } else {
                        if(y_screen_center > 4 + cube_size) {
                            y_screen_center -= 5;
                        }
                    }
                    break;
                case InputKeyOk:
                    move_or_rotate = !move_or_rotate;
                    break;

                default:
                    running = false;
                    break;
                }
            }
        }

        //All the drawing stuff is contained in the function update

        view_port_update(view_port);
    }

    /*we exited from this "running == true" loop, now we clean everythink up
        1. Disable the VIEWPORT
        2. Remove the VIEWPORT with gui library
        3. Free ViewStack instance


    */
    view_port_enabled_set(view_port, false);
    gui_remove_view_port(gui, view_port);
    view_port_free(view_port);
    furi_message_queue_free(event_queue);

    furi_record_close(RECORD_GUI);

    return 0;
}
